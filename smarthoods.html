<!DOCTYPE html>
<html lang="en">
	<head>
    <title>SmartHoods</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="css/main.css">
    <!-- <style>
        body {
            color: #444;
        }

        a {
            color: #444;
        }

        * {
            margin: 0;
            padding: 0
        }

        canvas {
            display: block
        }

        #container {
            width: 100vw;
            height: 100vh
        }
    </style> -->
</head>

<body>

    <div id="container"></div>

    <svg class="svg-map" data-id="map-1" xmlns="http://www.w3.org/2000/svg" width="2048" height="1024" style="visibility: : hidden" hidden>
        <path data-name="Фигура 1" class="cls-1" d="M292 1037s151.877-276.989 355-455l109 109 128-115 24 77s62.951-31.932 107-32l2 4s146.47-29.933 161-36 11.44 1.183 25-11 37.65-37.56 47-41 76 156 76 156 47.56-3.062 179 35l208 63s42.96-143.81 53-157 25.95-64.2 26-68 0 2 0 2 130.12-4.949 150-8 97.26-6.326 113-4" />
        <path data-name="Фигура 3" class="cls-1" d="M1904-6s-6.63 49.423-8 60-6 49-6 49-26.3 180.866-26 188 0 7 0 7-236.64-4.365-245-4 4 154 4 154l-77 2s2.99 19.305-2 23 3.18 11.805 3 18 0 116 0 116-51 4.849-58 5-2 18-2 18-105.05-9.242-109-9-38 0-38 0l-7-24-40 16 18 41-176 100s33.91 38.935 18 59-52 43-52 43-12.19.085-14 0-92 68-92 68-8.8.867-19 12-60 92-60 92" />
        <path data-name="Фигура 4" class="cls-1" d="M298-6l28 23-39 41 100 108-63 63 140 154 70-64 84 88 40-41 81 90s165.646-94.084 242-116 154-32 154-32l116 229s40.27-26.009 56-29 113.84-14.033 123-9l2 93 61 6-2 14s78.47-9.473 133-1c0 0-15.18 119.4 6 153l101 31s-12.76 109.682-5 113c0 0 104.63 13.546 138 17s103 17 103 17-31.9 82.06-37 88" />
        <path data-name="Фигура 5" class="cls-1" d="M1293 1027l-62-111-19-31-155 103s-35.41-48.044-73-78-100-95-100-95l-62-62-71 49-35-45-15-1-76 58s-32.554-14.514-46-8-113.353 80.845-119 87-29.007-34.438-44-44c0 0-1.64-10.346-15-16s-34-23-34-23l-70-94 176-172-138-134 39-37-97-100 161-162s40.968 38.6 41 43L617-10" />
        <path data-name="Фигура 6" class="cls-1" d="M1498-20s-66.97 83.057-72 91-48 62-48 62l-44 41s66.13 48.5 107 52 88-2 88-2l7 56s-151.33 5.792-179 17l-149 14s-24.27-14.187-65-7c0 0-125.21 28.353-166 38 0 0-10.783 10.379-24-48s-39-167-39-167-133.649 24.416-187 88L618 113 482 261l-65 65-215-219s-32.67 37.354-42 44S-15 259-15 259" />
        <path data-name="Фигура 2" class="cls-1" d="M1039-4l100 322s-138.77 28.06-160 41-94.242 55.153-99 58-111.15 55-189 117l7 7-47 38s-88.632-97-100-108c0 0-116.165 114.367-122 120s-90-89-90-89-106.484 108.558-115 113c0 0-22.994-37.881-43.116-49.51q-1.453-.84-2.884-1.49c-20.739-9.383-102.019 9.576-116 10s-67-11-67-11" />
        <path data-name="Фигура 7" class="cls-1" d="M98 1029l1 2s2.986-45.59-7-55-13-13-13-13 64.545-57.255 99-119l5-6s-76.227-43.539-78-46c0 0 24.235-32.7 24-36l-20-18s4.219-17.249 25-18h4s10.815-20.48 15-21l24 10s13.724-32.644 25-31 12 5 12 5l7-11s26.725-13.515 30-19c0 0-54.444-80.467-70-87s-3-3-3-3l160-157s-79.658-65.89-95-97l102-103-71-76 39-45-10-9 43-43 59 50 87-104" />
        <path data-name="Фигура 8" class="cls-1" d="M2067 150s-67.95 7.764-75 8-26 0-26 0-4.93-7.1-7 25-1 34-1 34l-25-1s.89 88.377-6 96c0 0-60.67-13.984-80-15 0 0-22.96-15.757-126-20h-78s6.54 88.869 9 111 38 315 38 315l-25 42-151-38s-14.42 33.564-27 42-79 84-79 84l43 93s59.14-22.7 115-10c0 0 12.4-2.95 13 6s1 104 1 104" />
        <path data-name="Фигура 9" class="cls-1" d="M650 1029s118.751-100.08 154-113c0 0 11.355-7.891 24 15 0 0 68.785-50.835 91-86l-33-33s67.645-69.243 102-80 44-20 44-20l-49-247 55-12a18.879 18.879 0 004-20c-4.4-12.274-7-11-7-11s-13.7-6.193-14.04-21.857c-.01-.695 0-1.41.04-2.143 0 0 81.69-20.453 92-24 0 0 7.1-6.293 12 6s5 14 5 14l-11 7s4.13 28.395 24 22 38-19 38-19l-28-67s162.12-20.633 180-21 44.5 2.367 85 1 191-15 191-15-82.94-158.176 17-310" />
        <path data-name="Фигура 10" class="cls-1" d="M-9 264l135 81 26-44s36.136 16.589 41 18 24 17 24 17l-89 129 13 14s14.153-13.733 34 3 30 31 30 31l25-26 16 7 92-86 175 186-28 21s-8.346 5.128 11 20l15 13s8.477 8.718-3 21l-11 20 30 25s95.757-107.645 122-129l359 349 86-72s60.97-45.391 79-53 153-114 153-114 71.59 110.621 81 137 76 177.08 77 193" />
        <path data-name="Фигура 11" class="cls-1" d="M1291-12l-13 36 147 47-47 61s31.46 41.933 148 27l10 139s194.73 3.161 230 7l29 207 86-4s111.79-13.255 167-7" />
        <path data-name="Фигура 12" class="cls-1" d="M2068 657s-19.12-8.761-34-5-202.33 21.169-225 16l-47-26-39 123s-315.3-91.669-398-92c0 0-14.99-20.86-32.26-57.3q-.87-1.823-1.74-3.7c-18-38.725-158-303-158-303s-196.267 36.481-232 60l-8-1-274-255L730-18" />
        <path data-name="Фигура 13" class="cls-1" d="M503 1035l39-31-9-15 68-33-48-71 102-35-31-38 74-53s2.609-42.8 53-73l5 5s119.52-112.127 127-115-69-114-69-114 138.973-78.274 189-92 141-31 141-31l-62-219-15-45s34.32-6.659 41-19 19-68 19-68" />
        <path data-name="Фигура 14" class="cls-1" d="M857-12s38.863 80.855 60 166 45 173 45 173-3.617 24.535 47 10 111.97-38.829 122-27 109 207 109 207 34.27-33.588 38-49c0 0 62.51-1.121 82-3s74-7 74-7 4.55 9.113 5 17-.78 24.578-5 25 0 92 0 92l58 6-30 97s-111.25-25.413-140-22l63 126s-74.3 59.838-78 62-75 52-75 52l65 118" />
        <path data-name="Фигура 15" class="cls-1" d="M2004-13s-10.76 179.234-9 211 2.73 132.292 2 134-142.38-48.948-375-46c0 0 .33 292.4 2 320s-2.62 134.3 7 157c0 0 9.13 4.933 4 14s-72 138-72 138 114.29 32.323 158 32l-1 90" />
        <path data-name="Фигура 16" class="cls-1" d="M2053 445s-10.28-5.555-17-6-15.63-4.735-17 2-4 30-4 30-1.2 5.558-4 7-6 7-6 7v15l-208 17s-45.5 214.316-74 244l-57-14-65 132s116.35 24.886 124 27 125 16 125 16 1.88-108.586 2-112 0-3 0-3 133.28 2.363 149 2 45-.765 56 2" />
        <path data-name="Фигура 17" class="cls-1" d="M2056 775s-92.89 14.445-139 15-150.12-10.626-194-29-165.93-42.576-232-60-166-31-166-31l-82-154s38.01-43.951 39-47 0 4 0 4 143.96-9.446 153-12l-13-163s1.46-6.908-12-5-190 17-190 17l-15-24s79.42-84.846 85-89 45.81-20.982 46-23 53-58 53-58-36.06-8.881-45-10-18.91-6.784-19-11-41-6-41-6-20.3-25.106 1-61l-94-35" />
        <path data-name="Фигура 18" class="cls-1" d="M844 1027s109.252-133.009 118-144 80.94-68.341 87-76l-32-180-21-102-54 19s-54.7 24.193-57 30-127 118-127 118L645 582 465 382l106-99 11 9 73-78-54-51s12.39-27.017 29-12l6 4 13-13-90-81 74-90" />
        <path data-name="Фигура 19" class="cls-1" d="M303 1027s42.386-80 102-159 191.331-238.8 240-282c0 0 6.742-4.245-2-13s-95-103-95-103l222-214-79-75s47.32-58.538 58-59 26 2 26 2 26.762-13.74 28-18-6-25-6-25a9.514 9.514 0 01-11-6c-3.216-7.907-11-28-11-28l91-39-6-33" />
        <path data-name="Фигура 20" class="cls-1" d="M-8 817l143 86s95.9-134.584 115-179 22-44 22-44-59.888-87.041-94-115l-73-67 135-188-51-56 33-35-65-71 46-47L72-12" />
        <path data-name="Фигура 21" class="cls-1" d="M-9 668s97.5-148.225 114-171 124.194-177.459 134-187 38-38 38-38l111-106 142 151 44-35 83 85 81 89s-113.265 74.974-122 89c0 0 174.9 176.615 185 187s157.714 147.187 159 151 103.94 105.8 107 143" />
        <path data-name="Фигура 22" class="cls-1" d="M1910-12l-10 42-112-13s-8.73 44.506-14 46c0 0 1.36 13.4 2 40s-6 123-6 123l-6 59s-99.87-8.614-239-1-300.64 25.132-318 24-33-9-52-7c0 0-29.38-111.121-30-114s-6.83-10.97-4-26c0 0-2.53-9.917-8-11s-6-13-6-13 5.12-3.429 15-2 13.81-2.883 12-9-18-48-18-48 .65-.293-10 3c0 0-5.94 3.84-8-3 0 0-14.23 1.817-10 10 0 0 .73 4.855 6 3s6.91-4.281 10 7 3 16 3 16-21.23 7.746-23 9-46-133-46-133" />
    </svg>




    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener noreferrer">SmartHoods site demo</a>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">

        uniform float time;
        varying vec2 vUv;
        varying vec3 vPosition;
        varying float vOpacity;
        uniform sampler2D texture1;
        attribute float opacity;
        float PI = 3.141592653589793238;

        void main() {

            vUv = uv;
            vOpacity = opacity;

            vec4 mvPosition = modelViewMatrix * vec4( position, 1. );

            gl_PointSize = 30000. * ( 1. / - mvPosition.z );
            gl_Position = projectionMatrix * mvPosition;

        }

    </script>


    <script id="fragmentShader" type="x-shader/x-fragment">


        uniform float time;
        uniform float progress;
        uniform sampler2D texture1;
        uniform vec4 resolution;
        varying vec2 vUv;
        varying vec3 vPosition;
        varying float vOpacity;
        float PI = 3.141592653589793238;

        void main() {

            vec2 uv = vec2(gl_PointCoord.x, 1. - gl_PointCoord.y);
            vec2 cUV = 2. * uv - 1.;
            vec3 originalColor = vec3(4. / 255., 10. / 255., 20. / 255.);
            vec4 color = vec4(0.01 / length(cUV)); // grootte

            color.rgb = min(vec3(10.), color.rgb);
            color.rgb *= originalColor * 1200.;
            color *= vOpacity;
            color.a = min(1., color.a) * 30.;

            float disc = length(cUV) ;
            // vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

            gl_FragColor = vec4(1. - disc, 0., 0., 1.) * vOpacity;
            gl_FragColor = vec4(color.rgb, color.a);
            // gl_FragColor = vec4(1.,1.,1.,1.);
        }

    </script>

    <script type="module" src="three.js-master/examples/jsm/controls/OrbitControls.js"></script>
    <!-- <script type="module" src="three.js-master/examples/jsm/controls/OrbitControls.js"></script>
    <script type="module" src="three.js-master/examples/jsm/controls/OrbitControls.js"></script>
    <script type="module" src="three.js-master/examples/jsm/controls/OrbitControls.js"></script>
    <script type="module" src="three.js-master/examples/jsm/controls/OrbitControls.js"></script> -->

    <script type="module">
        import * as THREE from '/three.js-master/build/three.module.js';

        import {
            OBB
        } from '/three.js-master/examples/jsm/math/OBB.js';
        import {
            OrbitControls
        } from '/three.js-master/examples/jsm/controls/OrbitControls.js';
        import {
            CSS2DRenderer,
            CSS2DObject
        } from '/three.js-master/examples/jsm/renderers/CSS2DRenderer.js';
        import {
            VRButton
        } from '/three.js-master/examples/jsm/webxr/VRButton.js';
        import {
            XRControllerModelFactory
        } from '/three.js-master/examples/jsm/webxr/XRControllerModelFactory.js';



        import Stats from '/three.js-master/examples/jsm/libs/stats.module.js';

        let camera, scene, renderer, labelRenderer, commCenter, moon, earth, clock, controls, stats, raycaster, hitbox, hoverObject, clickObject, isPlaying, time, svg;

        var lines = [];
        var particleSystem = [];
        var loaded = false;

        let theta = 0

        const textureLoader = new THREE.TextureLoader();


        const curves = []
        const objects = [],
            mouse = new THREE.Vector2();
        const lineText = new THREE.Object3D();

        const labelDiv = document.createElement('div');
        labelDiv.className = 'label';
        labelDiv.textContent = 'Earth';
        labelDiv.style.marginTop = '-1em';
        labelDiv.style.backgroundColor = 'rgba(0,155,255,0.05)';
        const label = new CSS2DObject(labelDiv);
        //earthLabel.position.set(0, 5, 0);

        const infoDiv = document.createElement('div');
        infoDiv.className = 'label';
        infoDiv.textContent = 'Earth';
        infoDiv.style.marginTop = '-1em';
        infoDiv.style.backgroundColor = 'rgba(0,155,255,0.05)';
        infoDiv.style.fontWeight = 'bold';
        const infoLabel = new CSS2DObject(infoDiv);
        //earthLabel.position.set(0, 5, 0);

        /*
                export default class Sketch {
                    constructor(options) {
                        this.scene = new THREE.Scene();

                        this.container = options.dom;
                        this.width = this.container.offsetWidth;
                        this.height = this.container.offsetHeight;
                        this.renderer = new THREE.WebGLRenderer();
                        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
                        this.renderer.setSize(this.width, this.height);
                        this.renderer.setClearColor(0x111111, 1);
                        this.renderer.physicallyCorrectLights = true;
                        this.renderer.outputEncoding = THREE.sRGBEncoding;

                        this.container.appendChild(this.renderer.domElement);

                        this.camera = new THREE.PerspectiveCamera(
                            70,
                            window.innerWidth / window.innerHeight,
                            100,
                            10000
                        );

                        // var frustumSize = 10;
                        // var aspect = window.innerWidth / window.innerHeight;
                        // this.camera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, -1000, 1000 );
                        this.camera.position.set(0, 0, 600);
                        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                        this.time = 0;

                        this.isPlaying = true;

                        this.getData()
                        this.addParticles();
                        this.resize();
                        this.render();
                        this.setupResize();
                        // this.settings();
                    }


                    getData() {
                        this.svg = [...document.querySelectorAll('.cls-1')]

                        this.lines = [];

                        this.svg.forEach((path, j) => {
                            let len = path.getTotalLength();
                            let numberOfPoints = Math.floor(len / 5);

                            let points = []

                            for (let i = 0; i < numberOfPoints; i++) {
                                let pointAt = len * i / numberOfPoints;
                                let p = path.getPointAtLength(pointAt);
                                let randX = (Math.random() - 0.5) * 5
                                let randY = (Math.random() - 0.5) * 5
                                points.push(new THREE.Vector3(p.x - 1024 + randX, p.y - 512 + randY, 0))

                            }

                            this.lines.push({
                                id: j,
                                path: path,
                                length: len,
                                pointCount: numberOfPoints,
                                points: points,
                                currentPos: 0,
                                speed: 1
                            })



                        })

                        console.log(this.lines);
                    }

                    settings() {
                        let that = this;
                        this.settings = {
                            progress: 0,
                        };
                        this.gui = new dat.GUI();
                        this.gui.add(this.settings, "progress", 0, 1, 0.01);
                    }

                    setupResize() {
                        window.addEventListener("resize", this.resize.bind(this));
                    }

                    resize() {
                        this.width = this.container.offsetWidth;
                        this.height = this.container.offsetHeight;
                        this.renderer.setSize(this.width, this.height);
                        this.camera.aspect = this.width / this.height;


                        // image cover
                        this.imageAspect = 853 / 1280;
                        let a1;
                        let a2;
                        if (this.height / this.width > this.imageAspect) {
                            a1 = (this.width / this.height) * this.imageAspect;
                            a2 = 1;
                        } else {
                            a1 = 1;
                            a2 = (this.height / this.width) / this.imageAspect;
                        }

                        this.material.uniforms.resolution.value.x = this.width;
                        this.material.uniforms.resolution.value.y = this.height;
                        this.material.uniforms.resolution.value.z = a1;
                        this.material.uniforms.resolution.value.w = a2;


                        // optional - cover with quad
                        // const dist  = this.camera.position.z;
                        // const height = 1;
                        // this.camera.fov = 2*(180/Math.PI)*Math.atan(height/(2*dist));

                        // // if(w/h>1) {
                        // if(this.width/this.height>1){
                        //   this.plane.scale.x = this.camera.aspect;
                        //   // this.plane.scale.y = this.camera.aspect;
                        // } else{
                        //   this.plane.scale.y = 1/this.camera.aspect;
                        // }

                        this.camera.updateProjectionMatrix();





                    }

                    // constructs the points trail using shader(material)s
                    addParticles() {
                        let that = this;
                        this.material = new THREE.ShaderMaterial({
                            extensions: {
                                derivatives: "#extension GL_OES_standard_derivatives : enable"
                            },
                            side: THREE.DoubleSide,
                            uniforms: {
                                time: {
                                    value: 0
                                },
                                resolution: {
                                    value: new THREE.Vector4()
                                },
                            },
                            // wireframe: true,
                            transparent: true,
                            depthTest: true,
                            depthWrite: true,
                            blending: THREE.AdditiveBlending,
                            vertexShader:
                                //vertex,//
                                document.getElementById('vertexShader').textContent,
                            fragmentShader:
                                //fragment
                                document.getElementById('fragmentShader').textContent //fragment
                        });

                        this.geometry = new THREE.PlaneGeometry(1, 1, 10, 10);
                        this.geometry = new THREE.BufferGeometry();

                        this.max = this.lines.length * 110;
                        this.positions = new Float32Array(this.max * 3);
                        this.opacity = new Float32Array(this.max);

                        // this.lines.forEach(line=>{
                        //   line.points.forEach(p=>{
                        //     this.positions.push(p.x,p.y,p.z);
                        //     this.opacity.push(Math.random()/5);
                        //   })
                        // })


                        // Set the random positions for eacht point on the line
                        for (let i = 0; i < this.max; i++) {
                            this.opacity.set([Math.random() / 10], i);
                            this.positions.set([Math.random() * 100, Math.random() * 1000, 0], i * 3)
                        }




                        this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                        this.geometry.setAttribute('opacity', new THREE.BufferAttribute(this.opacity, 1));

                        console.log(this.positions.length);

                        this.plane = new THREE.Points(this.geometry, this.material);
                        this.scene.add(this.plane);


                        //let texture = new THREE.TextureLoader().load(im);
                        //texture.flipY = false;
                        let map = new THREE.Mesh(
                            new THREE.PlaneBufferGeometry(2048, 1024, 1, 1),
                            new THREE.MeshBasicMaterial({
                                color: 0x000066,
                                //map: texture
                            })
                        )
                        this.scene.add(map);
                    }

                    stop() {
                        this.isPlaying = false;
                    }

                    play() {
                        if (!this.isPlaying) {
                            this.render()
                            this.isPlaying = true;
                        }
                    }

                    updateThings() {
                        let j = 0;



                        this.lines.forEach(line => {
                            line.currentPos += line.speed;
                            line.currentPos = line.currentPos % line.pointCount;
                            for (let i = 0; i < 100; i++) {
                                let index = (line.currentPos + i) % line.pointCount;
                                let p = line.points[index];
                                this.positions.set([p.x, p.y, p.z], j * 3)
                                this.opacity.set([Math.pow(i / 1000, 1.3)], j)
                                j++;
                            }
                        })




                        this.geometry.attributes.position.array = this.positions;
                        this.geometry.attributes.position.needsUpdate = true;
                    }

                    render() {
                        if (!this.isPlaying) return;
                        this.time += 0.05;

                        this.updateThings();
                        this.material.uniforms.time.value = this.time;
                        requestAnimationFrame(this.render.bind(this));
                        this.renderer.render(this.scene, this.camera);
                    }
                }

                new Sketch({
                    dom: document.getElementById("container")
                });*/


        init();
        animate();

        function init() {


            isPlaying = true;
            time = 0;


            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(-70, 75, -175);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            scene.fog = new THREE.FogExp2(0xffffff, 0.0035);

            clock = new THREE.Clock();

            raycaster = new THREE.Raycaster();

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x222222, 1.2);
            hemiLight.position.set(1, 1, 1);
            scene.add(hemiLight);


            // ground
            //var groundcolour2 = 0xfffff;
            ground(0xff00ff);

            function ground(groundcolour) {

                const ground = new THREE.Mesh(
                    new THREE.PlaneGeometry(2000, 2000),
                    new THREE.MeshPhongMaterial({
                        color: groundcolour,
                        depthWrite: false
                    })
                );
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0;
                ground.receiveShadow = true;
                scene.add(ground);

                const grid = new THREE.GridHelper(1000, 20, 0x5d5d5d, 0x5d5d5d);
                grid.material.opacity = 0.1;
                grid.material.transparent = true;
                grid.position.y = 0;
                scene.add(grid);

                const grid2 = new THREE.GridHelper(2000, 2, 0x000000, 0x000000);
                grid.material.opacity = 0.2;
                grid.material.transparent = true;
                grid.position.y = 0;
                //scene.add(grid2);

            }



            // text
            const loader = new THREE.FontLoader();
            loader.load('fonts/helvetiker_regular.typeface.json', function(font) {

                const color = 0x006699;

                const matDark = new THREE.LineBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide
                });

                const matLite = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });

                const message = "SmartHoods";

                const shapes = font.generateShapes(message, 20);

                const geometry = new THREE.ShapeGeometry(shapes);

                geometry.computeBoundingBox();

                const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);

                geometry.translate(xMid, 0, 0);

                // make shape ( N.B. edge view not visible )

                const text = new THREE.Mesh(geometry, matLite);
                text.position.z = 50;
                text.position.y = 50;
                text.rotation.y = Math.PI;
                scene.add(text);

                // make line shape ( N.B. edge view remains visible )

                const holeShapes = [];

                for (let i = 0; i < shapes.length; i++) {

                    const shape = shapes[i];

                    if (shape.holes && shape.holes.length > 0) {

                        for (let j = 0; j < shape.holes.length; j++) {

                            const hole = shape.holes[j];
                            holeShapes.push(hole);

                        }

                    }

                }

                shapes.push.apply(shapes, holeShapes);

                lineText.position.z = 51;
                lineText.position.y = 50;
                lineText.rotation.y = Math.PI;

                for (let i = 0; i < shapes.length; i++) {

                    const shape = shapes[i];

                    const points = shape.getPoints();
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);

                    geometry.translate(xMid, 0, 0);

                    const lineMesh = new THREE.Line(geometry, matDark);
                    lineText.add(lineMesh);

                }

                scene.add(lineText);

            }); //end load function


            // create houses
            const size = new THREE.Vector3(10, 5, 6);
            const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);

            // setup OBB on geometry level (doing this manually for now)

            geometry.userData.obb = new OBB();
            geometry.userData.obb.halfSize.copy(size).multiplyScalar(0.5);

            for (let i = 0; i < 50; i++) {

                const object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
                    color: 0xd3d3d3, //* Math.random() // 0x00ff00
                }));
                object.matrixAutoUpdate = false;

                var t = Math.random() * Math.PI * 2; // angle
                var r = 30 + Math.pow(Math.random(), 0.5) * 80; // radius

                object.rotation.x = 0; // Math.random() * 2 * Math.PI;
                object.rotation.y = 0; // Math.random() * 2 * 0;
                object.rotation.z = 0; // Math.random() * 2 * Math.PI;

                object.scale.x = Math.random() + 0.5;
                object.scale.y = Math.random() + 0.5;
                object.scale.z = Math.random() + 0.5;

                object.position.x = Math.cos(t) * r; // *Math.random() *  180 - 40;
                object.position.y = object.scale.y * 3;
                object.position.z = Math.sin(t) * r; // Math.random() * 180 - 40;

                scene.add(object);

                // bounding volume on object level (this will reflect the current world transform)

                object.name = 'house ' + i;
                object.ID = i;

                object.userData.obb = new OBB();

                objects.push(object);

            }


            // create lines
            for (let j = 0; j < objects.length; j++) { // for number of houses

                curves[j] = new THREE.Object3D();

                var houseParticleSystem = [];

                for (let i = 0; i < objects.length; i++) { // for each connecting house


                    const curve = new THREE.QuadraticBezierCurve3(
                        objects[i].position,
                        new THREE.Vector3(objects[i].position.x - (objects[i].position.x - objects[j].position.x) / 2, Math.pow(objects[i].position.distanceTo(objects[j].position), 0.5) * 5, objects[i].position.z - (objects[i].position.z - objects[j].position.z) / 2),
                        objects[j].position
                    );
                    //console.log(curve)
                    const points = curve.getPoints(50);
                    //console.log(points)
                    //console.log(curve.getSpacedPoints(50))
                    const particlesGeometry = new THREE.BufferGeometry().setFromPoints(points);

                    //console.log(particlesGeometry)
                    //curves[0].children[2].geometry.attributes.position.array


                    //console.log(particlesGeometry)

                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: 0.8 + Math.random() * 0.2 * 0x00ff00,
                        transparent: true,
                        opacity: 0.5
                    });

                    // Create the final object to add to the scene
                    const curveObject = new THREE.Line(particlesGeometry, lineMaterial);
                    console.log(curve)

                    //curveObject.points2 = particlesGeometry.attributes.position.array //curve.getSpacedPoints(50);

                    //curveObject.position.set(0, 0, 0);
                    //curveObject.visible = false;
                    curves[j].add(curveObject);

                    //lines.push(curveObject)
                    let lineParticles

                    if (j == 1 ) {
                        lineParticles = addParticles(particlesGeometry.attributes.position.array);

                        // add it to the scene
                        scene.add(lineParticles);
                        //console.log(i)
                        
                        lines.push({
                            object: curveObject,
                            id: i,
                            path: particlesGeometry.attributes.position.array,
                            length: Math.ceil(Math.random()*25),//particlesGeometry.attributes.position.count,
                            pointCount: particlesGeometry.attributes.position.count * 3,
                            points: points,
                            currentPos: 0,
                            speed: Math.ceil(Math.random()*3)
                        })

                    }

                    houseParticleSystem.push(lineParticles)


                    //console.log(lines[0])

                    //console.log(particlesGeometry.attributes.position.array)

                    /*
                    lines.push({
                        id: j,
                        path: path,
                        length: len,
                        pointCount: numberOfPoints,
                        points: points,
                        currentPos: 0,
                        speed: 1
                    })*/
                }

                particleSystem.push(houseParticleSystem)
                curves[j].visible = false;
                scene.add(curves[j]);

            }
            //console.log(lines)
            //console.log(particleSystem)
            //
            //curves.visible = false;f
            //scene.add(curves)

            //curves.traverse( function ( object ) { object.visible = false; } );



            // set default Hover and Click Object


            hoverObject = objects[0];
            clickObject = objects[0];

            //

            hitbox = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: true
            }));


            // add simple cube

            const geometry2 = new THREE.BoxGeometry(30, 10, 30);
            const material = new THREE.MeshLambertMaterial({
                color: 0xd3d3d3, //* Math.random() // 0x00ff00
                visible: false
            });
            commCenter = new THREE.Mesh(geometry2, material);
            commCenter.position.y = 5;

            scene.add(commCenter);


            //objects.push(commCenter);



            // add the label
            commCenter.add(label);
            commCenter.add(infoLabel);


            //

            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));


            //

            // 				
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            //

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            //

            const controllerModelFactory = new XRControllerModelFactory();

            const controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            const controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            //

            stats = new Stats();
            document.body.appendChild(stats.dom);


            //

            window.addEventListener('resize', onWindowResize);

            document.addEventListener('mousemove', onMouseOver);

            document.addEventListener('click', onClick);


            // functions
            //getData();

            loaded = true;


        }

        function getData() {
            svg = [...document.querySelectorAll('.cls-1')]

            lines = [];

            svg.forEach((path, j) => {
                let len = path.getTotalLength();
                let numberOfPoints = Math.floor(len / 5);

                let points = []

                for (let i = 0; i < numberOfPoints; i++) {
                    let pointAt = len * i / numberOfPoints;
                    let p = path.getPointAtLength(pointAt);
                    let randX = (Math.random() - 0.5) * 5
                    let randY = (Math.random() - 0.5) * 5
                    points.push(new THREE.Vector3(p.x - 1024 + randX, p.y - 512 + randY, 0))

                }

                lines.push({
                    id: j,
                    path: path,
                    length: len,
                    pointCount: numberOfPoints,
                    points: points,
                    currentPos: 0,
                    speed: 1
                })



            })

            console.log(lines[1].points);
        }

        // constructs the points trail using shader(material)s
        function addParticles(lineGeometry) {
            //let that = this;

            // create particles
            // var particleCount = 18,
            var particles = new THREE.BufferGeometry()
            var particleMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 10
            })
            var shaderMaterial = new THREE.ShaderMaterial({
                extensions: {
                    derivatives: "#extension GL_OES_standard_derivatives : enable"
                },
                side: THREE.DoubleSide,
                uniforms: {
                    time: {
                        value: 0
                    },
                    resolution: {
                        value: new THREE.Vector4()
                    },
                },
                // wireframe: true,
                transparent: false,
                depthTest: false,
                depthWrite: true,
                blending: THREE.AdditiveBlending,
                vertexShader:
                    //vertex,//
                    document.getElementById('vertexShader').textContent,
                fragmentShader:
                    //fragment
                    document.getElementById('fragmentShader').textContent //fragment
            });

            //console.log(particles)

            /*            // now create the individual particles
                        for (var p = 0; p < particleCount; p++) {

                            // create a particle with random
                            // position values, -250 -> 250
                            var pX = Math.random() * 50 - 25,
                                pY = Math.random() * 50 - 25,
                                pZ = Math.random() * 50 - 25,
                                particle = new THREE.Vector3(
                                    pX, pY, pZ
                                );

                            // add it to the geometry
                            //console.log(particles)
                            //particles.vertices.push(particle);


                        }
                        console.log(curves[0].children[0])
                        const vertices = new Float32Array([
                            -pX, -pY, -pZ,
                            pX, -2*pY, pZ,
                            pX, pY, pZ,

                            2*pX, pY, pZ,
                            -pX, 2*pY, 2*pZ,
                            -pX, -2*pY, 2*pZ
                        ]);*/

            //console.log(curves[0].children)


            let max = lineGeometry.length / 3
            let shaderOpacities = new Float32Array(max);
            let shaderPositions = lineGeometry;

            // console.log(shaderPositions.length / 3)
            //console.log(shaderOpacities)

            // lines.forEach(line=>{
            //   line.points.forEach(p=>{
            //     positions.push(p.x,p.y,p.z);
            //     opacity.push(Math.random()/5);
            //   })
            // })


            // Set the random positions for eacht point on the line

            for (let i = 0; i < max; i++) {
                shaderOpacities.set([Math.random() / 10], i);
                //shaderPositions.set([Math.random() * 10, Math.random() * 100, 0], i * 3)
                shaderPositions.set([
                        shaderPositions[0 + 3 * i] + (Math.random() - 0.5) * 2, // x
                        shaderPositions[1 + 3 * i] + (Math.random() - 0.5) * 2, // y
                        shaderPositions[2 + 3 * i] + (Math.random() - 0.5) * 2
                    ], // z
                    i * 3)
            }


            //particles.setAttribute('position', new THREE.BufferAttribute(curves[0].children[2].geometry.attributes.position.array, 3))


            particles.setAttribute('position', new THREE.BufferAttribute(shaderPositions, 3))
            particles.setAttribute('opacity', new THREE.BufferAttribute(shaderOpacities, 1));

            //   new Float32Array(Math.random()), 1))
            // particles.setAttribute('position', new THREE.BufferAttribute(vertices, 3))

            // create the particle system
            var lineParticles = new THREE.Points(
                particles,
                //particleMaterial,
                shaderMaterial
            );

            //console.log(lineParticles)

            return lineParticles

        }


        function onClick(event) {

            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersectionPoint = new THREE.Vector3();
            const intersections = [];

            for (let i = 0, il = objects.length; i < il; i++) {

                const object = objects[i];
                const obb = object.userData.obb;

                const ray = raycaster.ray;

                if (obb.intersectRay(ray, intersectionPoint) !== null) {

                    const distance = ray.origin.distanceTo(intersectionPoint);
                    intersections.push({
                        distance: distance,
                        object: object
                    });

                }

            }

            if (intersections.length > 0) {

                // determine closest intersection and highlight the respective 3D object


                intersections.sort(sortIntersections);

                // console.log(intersections[0])
                //intersections[0].object.add(hitbox);

                intersections[0].object.material.color.setHex(0x0088ff) // = rgb(250, 250,0) ;//.setHex('#ff0000');
                //console.log(intersections[0].object.ID

                //  console.log(intersections[0].object.ID)

                curves[intersections[0].object.ID].visible = true;
                curves[intersections[0].object.ID].traverse(function(child) {
                    if (child instanceof THREE.Line) {

                        //child.castShadow = true;
                        child.material.opacity = 0.5; // change color without dat.GUI
                    }
                });



                curves[clickObject.ID].visible = false;


                clickObject.material.color.setHex(0xd3d3d3)

                infoLabel.position.set(intersections[0].object.position.x, intersections[0].object.position.y + 15, intersections[0].object.position.z);
                infoDiv.textContent = 'test';
                console.log(intersections[0].object.name);

                clickObject = intersections[0].object;


            } else {

                /*                const parent = hitbox.parent;

                                if (parent) parent.remove(hitbox);*/

            }

        }


        function onMouseOver(event) {

            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersectionPoint = new THREE.Vector3();
            const intersections = [];

            for (let i = 0, il = objects.length; i < il; i++) {

                const object = objects[i];
                const obb = object.userData.obb;

                const ray = raycaster.ray;

                if (obb.intersectRay(ray, intersectionPoint) !== null) {

                    const distance = ray.origin.distanceTo(intersectionPoint);
                    intersections.push({
                        distance: distance,
                        object: object
                    });

                }

            }

            if (intersections.length > 0) {


                /*   if !(intersections[0].object.name = hoverObject.name) {
                       
                       
                       }
                       
                   hoverObject = intersections[0].object;
                   
                   console.log(!(intersections[0].object.name = hoverObject.name))
                   
                   */

                // determine closest intersection and highlight the respective 3D object

                intersections.sort(sortIntersections);
                // console.log(curves[intersections[0].object.ID].children)
                curves[intersections[0].object.ID].visible = true;

                if (intersections[0].object !== clickObject) {

                    curves[clickObject.ID].visible = false;


                    curves[intersections[0].object.ID].traverse(function(child) {
                        //console.log(child)
                        if (child instanceof THREE.Line) {
                            //console.log(child)

                            //child.castShadow = true;
                            child.material.opacity = 0.2; // change color without dat.GUI
                        }
                    });

                }


                //curves[clickObject.ID].material.opacity = 0.5;


                // new Object hovered
                if (intersections[0].object !== hoverObject) {

                    // hovered Object isnot clicked Object
                    if (hoverObject !== clickObject) {

                        hoverObject.material.color.setHex(0xd3d3d3)
                        curves[hoverObject.ID].visible = false;



                    }

                    //const parent = hitbox.parent;

                    //if (parent) parent.remove(hitbox);

                    //if (parent) parent.material.color.setHex(0xd3d3d3);

                    if (intersections[0].object !== clickObject) {

                        // curves[intersections[0].object.ID].visible = true;

                        intersections[0].object.material.color.setHex(0x808080) // = rgb(250, 250,0) ;//.setHex('#ff0000');

                    } else {

                    }

                    //console.log(intersections[0].object)
                    // move label to mouse

                    intersections[0].object.add(hitbox);

                    label.position.set(intersections[0].object.position.x, intersections[0].object.position.y + 5, intersections[0].object.position.z);
                    labelDiv.textContent = intersections[0].object.name;

                    hoverObject = intersections[0].object


                }

            } else {



                curves[hoverObject.ID].visible = false;

                curves[clickObject.ID].visible = true;

                //}
            }

        }

        function sortIntersections(a, b) {

            return a.distance - b.distance;

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            labelRenderer.setSize(window.innerWidth, window.innerHeight);

        }


        function updateParticleSystem() {
            // var time = Date.now()
            console.log(particleSystem)
            for (var i = 0; i < particleSystem.geometry.attributes.position.count; i++) {
                var particle = particleSystem.geometry.vertices[i];
                var path = particle.path;
                particle.lerpN += 0.05;
                if (particle.lerpN > 1) {
                    particle.lerpN = 0;
                    particle.moveIndex = particle.nextIndex;
                    particle.nextIndex++;
                    if (particle.nextIndex >= path.length) {
                        particle.moveIndex = 0;
                        particle.nextIndex = 1;
                    }
                }

                var currentPoint = path[particle.moveIndex];
                var nextPoint = path[particle.nextIndex];


                particle.copy(currentPoint);
                particle.lerp(nextPoint, particle.lerpN);
            }
            particleSystem.geometry.verticesNeedUpdate = true;
        };



        function updateParticles() {
            let i = 0;
            //let shaderPositions2 = particleSystem.geometry.attributes.position.array.slice();

            //let shaderOpacities2 = particleSystem[1][2].geometry.attributes.opacity.array;


            //console.log(particleSystem)
            // console.log(shaderPositions2)
            //console.log(lines)
            lines.forEach(line => {
                let shaderPositions3 = new Float32Array(51 * 3);
                let shaderOpacities2 = new Float32Array(51 * 3);
                //console.log(line.id)
                //console.log(line.points)
                line.currentPos += 2//line.speed;
                line.currentPos = line.currentPos % line.pointCount; //
                for (let i = 0; i < line.length; i++) {
                    let index = (line.currentPos + i) % 51 //line.pointCount;
                    let p = line.points[index];
                    //let p = shaderPositions2[index];
                    //console.log(index)
                    // console.log(p)
                    //console.log(line.pointCount)
                    //console.log(shaderOpacities2)
                    // console.log(shaderPositions2)
                    shaderPositions3.set([p.x, p.y, p.z], i * 3)
                    //console.log([Math.pow(i / 1000, 1.3)])
                    //console.log(i)
                    shaderOpacities2.set([Math.pow(i / 10000, 1.3)], i)
                    // i++;
                }
                particleSystem[1][line.id].geometry.attributes.position.array = shaderPositions3;
                particleSystem[1][line.id].geometry.attributes.position.needsUpdate = true;
            })
            //console.log(shaderOpacities2)



        }


        //

        function animate() {
            //await init();
            if (loaded == false) return

            requestAnimationFrame(animate);

            controls.update();

            // update Particles


            lineText.rotation.y += 0.0;

            // transform cubes

            const delta = clock.getDelta();

            for (let i = 0, il = objects.length; i < il; i++) {

                const object = objects[i];

                object.rotation.x += delta * Math.PI * 0.0;
                object.rotation.y += delta * Math.PI * 0.0;

                object.updateMatrix();
                object.updateMatrixWorld();

                // update OBB

                object.userData.obb.copy(object.geometry.userData.obb);
                object.userData.obb.applyMatrix4(object.matrixWorld);

                // reset

                //object.material.color.setHex(0xd3d3d3);

            }

            // collision detection

            for (let i = 0, il = objects.length; i < il; i++) {

                const object = objects[i];
                const obb = object.userData.obb;

                for (let j = i + 1, jl = objects.length; j < jl; j++) {

                    const objectToTest = objects[j];
                    const obbToTest = objectToTest.userData.obb;

                    // now perform intersection test

                    if (obb.intersectsOBB(obbToTest) === true) {

                        //object.material.color.setHex(0xd3d3d3);
                        //objectToTest.material.color.setHex(0xd3d3d3);

                    }

                }

            }
            //renderer.setAnimationLoop( render );

            //renderer.render(scene, camera);
            labelRenderer.render(scene, camera);

            stats.update();

        }

        renderer.setAnimationLoop(function() {

            theta += 1;


            camera.position.x += 0.1 * Math.sin(THREE.MathUtils.degToRad(theta / 10));
            camera.position.y += 0.09 * Math.sin(THREE.MathUtils.degToRad(theta / 10 + 28));
            camera.position.z += 0.1 * Math.cos(THREE.MathUtils.degToRad(0.07 * theta + 160));

            //camera.position.x = -100+100 * Math.sin( THREE.MathUtils.degToRad( 0.8* theta ) );
            //camera.position.y = 80+50 * Math.sin( THREE.MathUtils.degToRad( theta ) );
            //camera.position.z = -100+100 * Math.cos( THREE.MathUtils.degToRad( 0.7 * theta + 180) );
            //camera.lookAt( scene.position );
            camera.updateMatrixWorld();

            renderer.render(scene, camera);
            updateParticles();

            //updateParticleSystem();

        });
    </script>

</body></html>
